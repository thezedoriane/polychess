#python-chess import 
#https://github.com/niklasf/python-chess
import chess

#used to access Polyglot book
import chess.polyglot

#set the initial position
board = chess.Board()
print(board)

#mouvement possible
possibilite=board.legal_moves

def minmax(depth,board):
    '''renvoie le meilleur coup à faire en prévision du résultat des depth prochain coups a partir du plateau actuel
    pour le joueur couleur'''
    bestval=-999999
    bestmove=None
    possiblesmoves=board.legal_moves
    listMoves = []
    for move in possiblesmoves:
        listMoves.append(move)
    if depth==0:
        return evalb(board)
    else :
        for x in listMoves:
            move=chess.Move.from_uci(str(x))
            board.push(move)
            value=max(bestval,minmax(depth-1,board))
            if value>bestval:
                bestval=value
                bestmove=move
    return bestmove

def alphabeta(depth,alpha,beta,board,player):
    '''on renvoie la valeur du coup en prenant en compte le choix de l'adversaire
    depth est le nombre de coup à l'avance que l'on veut prévoir
    alpha est la valeur min des coups possibles pour le joueur
    beta est la valeur max des coups possibles pour le joueur
    board est la situation actuelle du jeu
    player est un booléen qui indique vrai si c'est au tour joueur qui cherche quel coup joué 
    et faux si c'est au coup de l'adversaire'''
    possiblesmoves=board.legal_moves
    listMoves = []
    for move in possiblesmoves:
        listMoves.append(move)  #création de la liste des mouvements
    if depth==0:
        '''si on arrive au bout des depth coups on évalue le tableau'''
        return evalb(board)
    else :
        if player:
            for x in listMoves:
                move=chess.Move.from_uci(str(x))
                board.push(move)
                value=alphabeta(depth-1,alpha,beta,board,not(player))
                board.pop()
                if value>=beta:
                    return beta
                if value>alpha:
                    alpha=value
            return alpha
        else:
            for x in listMoves:
                move=chess.Move.from_uci(str(x))
                board.push(move)
                value=alphabeta(depth-1,alpha,beta,board,not(player))
                board.pop()
                if value<=alpha:
                    return alpha
                if value<beta:
                    beta=value
            return beta

def choix_meilleur_coup_ab(board,depth):
    '''Renvoie le meilleur mouvement à faire selon l'algorithme alphabeta
    board est le tableau actuel, depth est la nombre de coup à l'avance que l'on veut prévoir'''
    possiblesmoves=board.legal_moves
    listMoves = []
    for move in possiblesmoves:
        listMoves.append([move])
    for i in range (len(listMoves)):
        move=chess.Move.from_uci(str(listMoves[i][0]))
        board.push(move)
        listMoves[i].append(alphabeta(depth,-99999,99999,board,True))
        board.pop()
    best=listMoves[0][1]
    for i in range(1,len(listMoves)):
        best=max(listMoves[i][1],best)
    bestmoves=[]
    for i in range(len(listMoves)):
        if listMoves[i][1]==best:
            bestmoves.append(listMoves[i][0]) 
    print(bestmoves)

def evalb(board):
    '''renvoie la valeur d'un plateau en fonction du nombre de piece restante sur le plateau '''
    evalb=0
    for pos in range(64):
        if board.piece_at(pos).color: 
            evalb+=getPieceValue(str(board.piece_at(pos)))
        else:
            evalb-=getPieceValue(str(board.piece_at(pos)))
    return evalb
    
    
       
def getPieceValue(piece):
        '''renvoie la valeur de la piece'''
        if(piece == None):
            return 0
        value = 0
        if piece == "P" or piece == "p":
            value = 1
        if piece == "N" or piece == "n":
            value = 3
        if piece == "B" or piece == "b":
            value = 3
        if piece == "R" or piece == "r":
            value = 6
        if piece == "Q" or piece == "q":
            value = 9
        if piece == 'K' or piece == 'k':
            value = 10000 
        return value
